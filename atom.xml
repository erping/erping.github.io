<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[薛定谔的喵]]></title>
  <subtitle><![CDATA[成长之路]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-07T08:41:24.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[erping]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LVS集群体系架构]]></title>
    <link href="http://yoursite.com/2016/05/06/LVS%E9%9B%86%E7%BE%A4%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2016/05/06/LVS集群体系架构/</id>
    <published>2016-05-06T08:25:29.000Z</published>
    <updated>2016-05-07T08:41:24.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<ul>
<li><strong>引言</strong></li>
</ul>
<p>互联网在近十几年发展迅猛，已经成为人们生活中密不可分的一部分，大型网站的PV常常过亿，这对网站体系架构提出挑战。因为系统必须是高性能，高可靠的，尤其当访问负载不断增长时，系统必须能被扩展来满足不断增长的性能需求。现在后台服务器一般都是集群的方式，需要利用负载均衡的技术将请求分发到集群中，负载均衡的方式一般有LVS，Nginx和HAproxy，今天主要说一下LVS的体系结构。</p>
<ul>
<li><strong>LVS通用体系结构</strong></li>
</ul>
<p>LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服 务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。<br><img src="http://7xp01p.com1.z0.glb.clouddn.com/LVS.png" alt=""></p>
<p>一般来说，LVS集群采用三层结构，其体系结构如上图所示，三层主要组成部分为：</p>
<ol>
<li><strong>负载调度器</strong>（load balancer），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的。</li>
<li><strong>服务器池</strong>（server pool），是一组真正执行客户请求的服务器，执行的服务有WEB、MAIL、FTP和DNS等。</li>
<li><strong>共享存储</strong>（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</li>
</ol>
<p>调度器是服务器集群系统的唯一入口点，它可以采用IP负载均衡技术、基于内容请求分发技术或者两者相结合。在IP负载均衡技术中，需要服务器池拥有相同的内容提供相同的服务。当 客户请求到达时，调度器只根据服务器负载情况和设定的调度算法从服务器池中选出一个服务器，将该请求转发到选出的服务器，并记录这个调度；当这个请求的其 他报文到达，也会被转发到前面选出的服务器。在基于内容请求分发技术中，服务器可以提供不同的服务，当客户请求到达时，调度器可根据请求的内容选择服务器 执行请求。因为所有的操作都是在Linux操作系统核心空间中将完成的，它的调度开销很小，所以它具有很高的吞吐率。</p>
<p>服务器池的结点数目是可变的。当整个系统收到的负载超过目前所有结点的处理能力时，可以在服务器池中增加服务器来满足不断增长的请求负载。对大多数 网络服务来说，请求间不存在很强的相关性，请求可以在不同的结点上并行执行，所以整个系统的性能基本上可以随着服务器池的结点数目增加而线性增长。</p>
<p>共享存储通常是数据库、网络文件系统或者分布式文件系统。服务器结点需要动态更新的数据一般存储在数据库系统中，同时数据库会保证并发 访问时数据的一致性。分布式文件系统可为各服务器提供共享的存储区，它们访问分布式文件系统就像访问本地文件系统一样，同时分布式文件系统可提 供良好的伸缩性和可用性。</p>
<ul>
<li><strong>系统优点</strong></li>
</ul>
<p>LVS采用以上的系统架构使得其有很多优点：</p>
<p> <strong>层次体系结构</strong></p>
<p>层次的体系结构可以使得层与层之间相互独立，每一个层次提供不同的功能，在一个层次可以重用不同的已有软件。例如，调度器层提供了负载平衡、可伸缩 性和高可用性等，在服务器层可以运行不同的网络服务，如Web、Cache、Mail和Media等，来提供不同的可伸缩网络服务。明确的功能划分和清晰 的层次结构使得系统容易建设，以后整个系统容易维护，而且系统的性能容易被扩展。</p>
<p> <strong>共享存储</strong></p>
<p>共享存储如分布式文件系统在这个LVS集群系统是可选项。当网络服务需要有相同的内容，共享存储是很好的选择，否则每台服务器需要将相同的 内容复制到本地硬盘上。当系统存储的内容越多，这种无共享结构的代价越大，因为每台服务器需要一样大的存储空间，任何的更新需要涉及到每台服务器，系统的维护代价会非常高。</p>
<p>共享存储为服务器组提供统一的存储空间，这使得系统的内容维护工作比较轻松，如Webmaster只需要更新共享存储中的页面，对所有 的服务器都有效。分布式文件系统提供良好的伸缩性和可用性，当分布式文件系统的存储空间增加时，所有服务器的存储空间也随之增大。对于大多数 Internet服务来说，它们都是读密集型的应用，分布式文件系统在每台服务器使用本地硬盘作Cache（如 2Gbytes的空间），可以使得访问分布式文件系统本地的速度接近于访问本地硬盘。</p>
<p> <strong>高可用性</strong></p>
<p>集群系统的特点是它在软硬件上都有冗余。系统的高可用性可以通过检测节点或服务进程故障和正确地重置系统来实现，使得系统收到的请求能被存活的结点处理。</p>
<p>通常，我们在调度器上有资源监测进程来时刻监视各个服务器结点的健康状况。当服务器对ICMP ping不可达时或者探测她的网络服务在指定的时间没有响应时，资源监测进程通知操作系统内核将该服务器从调度列表中删除或者失效。这样，新的服务请求就 不会被调度到坏的结点。资源监测进程能通过电子邮件或传呼机向管理员报告故障。一旦监测进程到服务器恢复工作，通知调度器将其加入调度列表进行调度。另 外，通过系统提供的管理程序，管理员可发命令随时可以将新机器加入服务来提高系统的处理性能，也可以将已有的服务器切出服务，以便对服务器进行系统维护。</p>
<p>现在前端的调度器有可能成为系统的单一失效点（Single Point of Failure）。一般来说，调度器的可靠性较高，因为调度器上运行的程序较少而且大部分程序早已经遍历过，但我们不能排除硬件老化、网络线路或者人为误 操作等主要故障。为了避免调度器失效而导致整个系统不能工作，我们需要设立一个从调度器作为主调度器的备份。两个心跳（Heartbeat）进程[6]分 别在主、从调度器上运行，它们通过串口线和UDP等心跳线来相互定时地汇报各自的健康状况。当从调度器不能听得主调度器的心跳时，从调度器通过ARP欺骗 （Gratuitous ARP）来接管集群对外的Virtual IP Address，同时接管主调度器的工作来提供负载调度服务。当主调度器恢复时，这里有两种方法，一是主调度器自动变成从调度器，二是从调度器释放 Virtual IP Address，主调度器收回Virtual IP Address并提供负载调度服务。这里，多条心跳线可以使得因心跳线故障导致误判（即从调度器认为主调度器已经失效，其实主调度器还在正常工作）的概论 降到最低。</p>
<p>通常，当主调度器失效时，主调度器上所有已建立连接的状态信息将丢失，已有的连接会中断。客户需要向重新连接，从调度器才会将新连接调 度到各个服务器上，这对客户会造成一定的不便。为此，IPVS调度器在Linux 内核中实现一种高效状态同步机制，将主调度器的状态信息及时地同步到从调度器。当从调度器接管时，绝大部分已建立的连接会持续下去。</p>
<p>参考：<a href="http://www.linuxvirtualserver.org/zh/lvs2.html" target="_blank" rel="external">http://www.linuxvirtualserver.org/zh/lvs2.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="LVS" scheme="http://yoursite.com/tags/LVS/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <link href="http://yoursite.com/2016/04/22/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/22/布隆过滤器/</id>
    <published>2016-04-22T14:27:38.000Z</published>
    <updated>2016-04-22T14:30:46.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<ul>
<li><strong>简介</strong></li>
</ul>
<p>上篇博客里介绍了位图法，可以判断一个数是否在一个很大的集合里。但是如果问题换成有1亿个邮件地址，如何确定某个邮件地址是否在这个集合里中？这个时候最容易想到的方法就是Hash表了，但是大家可以细想一下，如果利用Hash表来处理，必须开辟空间去存储这1亿个邮件地址，因为在Hash表中不可能避免的会发生碰撞，假设一个邮件地址只占8个字节，为了保证Hash表的碰撞率，所以需要控制Hash表的装填因子在0.5左右，那么至少需要2<em>8</em>108/1024<em>1024</em>1024=1.5G的内存空间，这种情况下利用Hash表是无法处理的。这个时候要用到另外一种数据结构-布隆过滤器（Bloom Filter）它结合了位图和Hash表两者的优点，位图的优点是节省空间，但是只能处理整型值一类的问题，无法处理字符串一类的问题，而Hash表却恰巧解决了位图无法解决的问题，然而Hash太浪费空间。针对这个问题，布隆提出了一种基于二进制向量和一系列随机函数的数据结构-布隆过滤器。它的空间利用率和时间效率是很多算法无法企及的，但是它也有一些缺点，就是会有一定的误判率并且不支持删除操作。</p>
<ul>
<li><strong>算法描述</strong></li>
</ul>
<p>一个empty bloom filter是一个有m bits的bit array，每一个bit位都初始化为0。并且定义有k个不同的hash function，每个都以uniform random distribution将元素hash到m个不同位置中的一个。在下面的介绍中n为元素数，m为布隆过滤器或哈希表的slot数，k为布隆过滤器重hash function数。</p>
<p>为了add一个元素，用k个hash function将它hash得到bloom filter中k个bit位，将这k个bit位置1。<br><img src="http://7xp01p.com1.z0.glb.clouddn.com/bloomfilter.png" alt=""></p>
<p>为了query一个元素，即判断它是否在集合中，用k个hash function将它hash得到k个bit位。若这k bits全为1，则此元素在集合中；若其中任一位不为1，则此元素比不在集合中（因为如果在，则在add时已经把对应的k个bits位置为1）。</p>
<p>不允许remove元素，因为那样的话会把相应的k个bits位置为0，而其中很有可能有其他元素对应的位。因此remove会引入false negative，这是绝对不被允许的(不过现在也有支持删除的布隆过滤器)。</p>
<p>Bloom Filter会有一定的误判率，假设对一个元素进行了hash映射，结果相应的几个位都为1(这些位可能是其他元素映射出来的)，那仍会将其判为在集合中。这就是false positive，从直觉上我们可以判断这一误判率会和映射函数的个数还有bit array的大小有关。具体证明可以<a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="external">参考这里</a>。</p>
<ul>
<li><strong>应用场景</strong></li>
</ul>
<p>布隆过滤器在很多场合能发挥很好的效果，比如：网页URL的去重，垃圾邮件的判别，集合重复元素的判别，查询加速（比如基于key-value的存储系统）等，下面举个例子：</p>
<p>有两个URL集合A,B，每个集合中大约有1亿个URL，每个URL占64字节，有1G的内存，如何找出两个集合中重复的URL。</p>
<p>第一种：如果不允许一定的错误率的话，只有用分治的思想去解决，将A,B两个集合中的URL分别存到若干个文件中{f1,f2…fk}和{g1,g2….gk}中，然后取f1和g1的内容读入内存，将f1的内容存储到hash_map当中，然后再取g1中的url，若有相同的url，则写入到文件中，然后直到g1的内容读取完毕，再取g2…gk。然后再取f2的内容读入内存。。。依次类推，知道找出所有的重复url。</p>
<p>第二种：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查Bloom filter的相应位，如果都是1，那么该url应该是共同的url。</p>
<ul>
<li><strong>代码实现</strong></li>
</ul>
<p>下面给出一个简单的代码实现：</p>
<pre><code>bitset&lt;<span class="type">MAX</span>&gt; bloomSet;
<span class="comment">#define MAX 2&lt;&lt;24</span>
<span class="type">int</span> seeds[<span class="number">7</span>]={<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">61</span>};

<span class="type">int</span> getHashValue（<span class="type">string</span> str, <span class="type">int</span> n)
{
    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;
    <span class="type">int</span> i;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;str.size(); i++)
    {
        <span class="literal">result</span> = seeds[n]*<span class="literal">result</span> + (<span class="type">int</span>)str[i];
        <span class="keyword">if</span>(<span class="literal">result</span> &gt; <span class="number">2</span>&lt;&lt;<span class="number">24</span>)
            <span class="literal">result</span> %= <span class="number">2</span>&lt;&lt;<span class="number">24</span>;
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
}

<span class="type">bool</span> isInBloomSet(<span class="type">string</span> str)
{
    <span class="type">int</span> i;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)
    {
        <span class="type">int</span> hash = getHashValue(str,i);
        <span class="keyword">if</span>(bloomSet[hash] == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="type">void</span> addToBloomSet(<span class="type">string</span> str)
{
    <span class="type">int</span> i;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)
    {
        <span class="type">int</span> hash = getHashValue(str,i);
        bloomSet.<span class="type">set</span>(hash,<span class="number">1</span>);
    }
}

<span class="type">void</span> initBloomSet()
{
    addToBloomSet(<span class="string">"www.google.com"</span>);
    addToBloomSet(<span class="string">"www.baidu.com"</span>);
    addToBloomSet(<span class="string">"www.qq.com"</span>);
    addToBloomSet(<span class="string">"www.alibaba.com"</span>);
}
</code></pre><p>参考：[1] <a href="http://www.cnblogs.com/dolphin0520/archive/2012/11/10/2755089.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/archive/2012/11/10/2755089.html</a><br>[2] <a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="external">http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="bloom filter" scheme="http://yoursite.com/tags/bloom-filter/"/>
    
      <category term="集合交集" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88%E4%BA%A4%E9%9B%86/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位图法]]></title>
    <link href="http://yoursite.com/2016/04/22/%E4%BD%8D%E5%9B%BE%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/22/位图法/</id>
    <published>2016-04-22T13:10:51.000Z</published>
    <updated>2016-04-22T13:15:11.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>位图就是bitmap，也就是用一个位来表示某种状态，特别适合数据规模很大，但是数据状态很少的情况。通常用来判断某个数是否存在于集合中。在STL中就有一个叫做bitset的容器，其实就是位图法，引用bitset的介绍：</p>
<blockquote>
<p><em>A bitset is a special container class that is designed to store bits (elements with only two possible values: 0 or 1,true or false, …).The class is very similar to a regular array, but optimizing for space allocation: each element occupies only one bit (which is eight times less than the smallest elemental type in C++: char).Each element (each bit) can be accessed individually: for example, for a given bitset named mybitset, the expression mybitset[3] accesses its fourth bit, just like a regular array accesses its elements.</em></p>
</blockquote>
<ul>
<li><strong>数据结构</strong></li>
</ul>
<p>我们都知道一个字节有8个位，那么表示一个最大值小于等于15的集合用两个字节就可以。</p>
<p><img src="http://7xp01p.com1.z0.glb.clouddn.com/bitmap1.jpg" alt=""></p>
<p>如果将数组[2,10,3,6,14,0]存入上面的位图中，结果为（低位在右侧）</p>
<p><img src="http://7xp01p.com1.z0.glb.clouddn.com/bitmap2.jpg" alt=""></p>
<p>从上图可以清楚的看到存数据的时候只要把相应数据所在的位置1即可。</p>
<ul>
<li><strong>实际应用</strong></li>
</ul>
<p>一、排序</p>
<p>输入：给定一个文件，里面最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数），且其中每个数都小于等于n，n=10^7。 输出：得到按从小到大升序排列的包含所有输入的整数的列表。 条件：最多有大约1.5MB的内存空间可用，但磁盘空间足够.</p>
<p>通过分析我们可以发现这个问题有其特殊性：</p>
<ol>
<li>输入数据限制在相对较小的范围内；</li>
<li>数据没有重复；</li>
<li>其中每条记录都是单一的整数，没有任何其他与之关联的数据。</li>
</ol>
<p>所以，可以用位图的方案分以下三部解决：</p>
<ol>
<li>根据数据规模创建位图，并将所有位置0；</li>
<li>通过读入文件的每个整数建立集合，将每个数对应位置1；</li>
<li>遍历创建好的集合，如果该位为1，就输出对应位代表的数字。</li>
</ol>
<p>伪代码如下表示：</p>
<pre><code><span class="keyword">for</span> i = {0,....<span class="keyword">n</span>}
    bit[i] = 0;
<span class="keyword">for</span> each i <span class="keyword">in</span> the <span class="keyword">input</span> <span class="keyword">file</span>
    bit[i] = 1;
<span class="keyword">for</span> i = {0,....<span class="keyword">n</span>}
    <span class="keyword">if</span> bit[i] == 1
        write i <span class="keyword">on</span> the output <span class="keyword">file</span>
</code></pre><p>二、查找</p>
<p>问题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>40亿个数大约就是4G个数，按照位图每位存一个数的话，需要4G/8=512M的内存，读入这些数据，设置相应的bit位，读入要查询的数，在位图中查看相应位是否为1，为1表示存在，为0表示不存在。</p>
<p>问题扩展：在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p>一般来说位图适用于数据状态少的情况，1位的话只能表示存在与否，此问题要求的是找出不重复的数，1位就不够用了，所以需要扩展位图用2位来表示更多的状态（每个数分配2bit，00表示不存在，01表示出现一次，10表示出现多次，11无意义），这样需要2^32*2bit=1GB内存。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>位图就是一种用位置和状态来描述原来数据的压缩方法，在某些情况下能够用较小的空间/时间复杂度来解决问题，特别是大规模数据的时候。</p>
<p>参考：[1].<a href="http://blog.csdn.net/wypblog/article/details/8237956" target="_blank" rel="external">http://blog.csdn.net/wypblog/article/details/8237956</a></p>
<p>[2].<a href="http://the-art-of-programming-by-july.readthedocs.org/en/latest/ebook/zh/06.07/" target="_blank" rel="external">http://the-art-of-programming-by-july.readthedocs.org/en/latest/ebook/zh/06.07/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="bitmap" scheme="http://yoursite.com/tags/bitmap/"/>
    
      <category term="海量数据" scheme="http://yoursite.com/tags/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bash快捷键]]></title>
    <link href="http://yoursite.com/2016/04/13/Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2016/04/13/Bash快捷键/</id>
    <published>2016-04-13T08:50:07.000Z</published>
    <updated>2016-04-13T08:51:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>当你输入了一长串的命令却发现开头有错误的时候，你会一直按&lt;-使光标移动过去么？当你忘记之前输入的命令的全称的时候你会先history然后执行么？少年，工欲善其事必先利其器，学习一些bash快捷键让你又cool又快。</p>
<p>Ctrl-A 相当于HOME键，用于将光标定位到本行最前面</p>
<p><strong>Ctrl-E 相当于End键，即将光标移动到本行末尾</strong></p>
<p>Ctrl-B 相当于左箭头键，用于将光标向左移动一格</p>
<p>Ctrl-F 相当于右箭头键，用于将光标向右移动一格</p>
<p>Ctrl-D 相当于Del键，即删除光标所在处的字符</p>
<p>Ctrl-K 用于删除从光标处开始到结尾处的所有字符</p>
<p><strong>Ctrl-L 清屏，相当于clear命令</strong></p>
<p><strong>Ctrl-R 进入历史命令查找状态，然后你输入几个关键字符，就可以找到你使用过的命令</strong></p>
<p><strong>Ctrl-U 用于删除从光标开始到行首的所有字符。一般在密码或命令输入错误时常用</strong></p>
<p>Ctrl-H 删除光标左侧的一个字符</p>
<p>Ctrl-W 用于删除当前光标左侧的一个单词</p>
<p><strong>Ctrl-P 相当于上箭头键，即显示上一个命令</strong></p>
<p>Ctrl-N 相当于下箭头键，即显示下一个命令</p>
<p>Ctrl-J 相当于回车键</p>
<p>Alt-. 用于提取历史命令中的最后一个单词。你先执行history命令，然后再敲击此快捷键若干下，你就懂了！</p>
<p>Alt-BackSpace 用于删除本行所有的内容，基本上和Ctrl-U类似。</p>
<p>Alt-C 用于将当前光标处的字符变成大写，同时本光标所在单词的后续字符都变成小写。</p>
<p>Alt-L 用于将光标所在单词及所在单词的后续字符都变成小写。</p>
<p>Alt-U 用于将光标所在单词的光标所在处及之后的所有字符变成大写。</p>
<p>黑体的是推荐的常用快捷键，多用几次很快就熟悉啦。人生又省出很多时间，可以进行思考了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux创建进程的方法]]></title>
    <link href="http://yoursite.com/2016/03/02/Linux%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/03/02/Linux创建进程的方法/</id>
    <published>2016-03-02T14:51:00.000Z</published>
    <updated>2016-04-02T14:58:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>在Linux中主要提供了fork、vfork、clone三种创建进程的方法。下面我们分别介绍他们的特点以及不同之处。</p>
<p><strong>fork</strong></p>
<p>创建进程最常用的就是fork，这样得到的子进程完全复制父进程的资源，仅有少量信息如task_struct结构和pid父子进程是不同的。但是比如文件描述符，打开的文件的读写位置指针等都是相同的。这样得到的子进程独立于父进程，具有良好的并发性，但是两者之间的通信需要专门的通信机制比如管道，共享内存。因为子进程存有父进程的资源副本，所以fork是一个开销很大的系统调用。有时候这样是很不必要的，比如fork出来的子进程仅仅是为了调用exec执行另外的程序，那么fork过程的复制将是一个多余的过程。现在的Linux采用了写时复制的技术，为了降低开销，fork最初并不会真正产生两个不同的拷贝，因为那个时候，大量的数据其实是一样的。写时复制推迟了真正的数据拷贝。若后来确实发生了写入，那那意味着parent和child的数据不一致了，于是产生复制动作，每个进程拿到属于自己的那一份，这样就可以降低系统调用的开销。所以有了写时复制后呢，vfork其实现意义就不大了(后面会讲到)。</p>
<p>fork调用执行一次返回两个值，对于父进程，fork函数返回子程序的进程号，而对于子程序，fork函数则返回零，这就是一个函数返回两次的本质。 </p>
<p>在fork之后，子进程和父进程都会继续执行fork调用之后的指令。子进程是父进程的副本。它将获得父进程的数据空间，堆和栈的副本，这些都是副本，父子进程并不共享这部分的内存。也就是说，子进程对父进程中的同名变量进行修改并不会影响其在父进程中的值。但是父子进程又共享一些东西，简单说来就是程序的正文段。正文段存放着由cpu执行的机器指令，通常是read-only的。</p>
<p><strong>vfork</strong></p>
<p>既然有了fork，为什么还会有vfork呢？看fork的man page我们就可以知道啦。</p>
<p><em>In the bad old days a fork would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterwards an exec is done. Thus, for greater efficiency, BSD introduced the vfork system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of control until a call to execve or an exit occurred. The parent process was suspended while the child was using its resources. The use of vfork was tricky: for example, not modifying data in the parent process depended on knowing which variables are held in a register</em></p>
<p>就是为了处理上文分析的fork后子进程马上exec一个外部程序使得复制没意义这样的问题，BSD提出了vfork，这样会使父子进程共享地址空间。这个时候如果子进程修改了某个变量，父进程也会做同样的修改。</p>
<p>但此处有一点要注意的是用vfork创建的子进程必须显示调用exit()来结束，用return会挂掉，详细情况有兴趣的可以参考<a href="http://coolshell.cn/articles/12103.html" target="_blank" rel="external">这篇文章</a>。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec或exit，这也就是说vfork会保证子进程先运行，而fork的情况下两者是竞争关系，运行顺序无法得到保证。</p>
<p><strong>clone</strong></p>
<p>clone的函数原型<br>int clone(int (<em>fn)(void </em>), void <em>child_stack, int flags, void </em>arg);</p>
<p>系统调用fork和vfork是无参数的，而clone则带有参数。fork是全部复制，vfork是共享内存，而clone是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 flags来决定。另外，clone返回的是子进程的pid。</p>
<p>以上就是Linux下的几种创建进程的方式，vfork比较危险，如果不是特别关注性能不建议使用，clone提供了复杂的参数，可以实现对子进程较为精细的控制，在实践中应该根据自己需求选择合适的调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="clone" scheme="http://yoursite.com/tags/clone/"/>
    
      <category term="fork" scheme="http://yoursite.com/tags/fork/"/>
    
      <category term="vfork" scheme="http://yoursite.com/tags/vfork/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <link href="http://yoursite.com/2016/01/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/01/30/linux常用命令/</id>
    <published>2016-01-30T03:06:24.000Z</published>
    <updated>2016-03-30T03:20:42.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>自己电脑以前用的就是Ubuntu的，虽然不怎么方便，但是命令用的熟啊。后来重装了Windows，命令逐渐生疏，今天就总结一下，算是温故知新。</p>
<p> <strong>帮助命令</strong></p>
<p>$<strong>man</strong> <em>command</em></p>
<p>查询命令<em>command</em>的说明文档</p>
<p>$<strong>info</strong> <em>command</em></p>
<p>更加详细的说明文档</p>
<p>$<strong>whatis</strong> <em>command</em></p>
<p>简要说明</p>
<p>$<strong>which</strong> <em>command</em></p>
<p><em>command</em>的binary文件所在路径</p>
<p>$<strong>whereis</strong> <em>command</em></p>
<p>在搜索路径中的所有<em>command</em></p>
<p> <strong>用户</strong></p>
<p>$<strong>finger</strong> <em>username</em></p>
<p>显示用户<em>username</em>的信息</p>
<p>$<strong>who</strong></p>
<p>显示当前登录的用户</p>
<p>$<strong>passwd</strong></p>
<p>更改密码</p>
<p> <strong>SHELL（BASH）</strong></p>
<p>$<strong>history</strong></p>
<p>显示当前shell下的命令历史</p>
<p>$<strong>!num</strong></p>
<p>!加在<em>history</em>后的数字即为执行那条命令</p>
<p>$<strong>alias</strong></p>
<p>显示所有的命令别名</p>
<p>$<strong>alias new_command=’command’</strong></p>
<p>将command用newcommand代替</p>
<p>$<strong>expr 1 + 1</strong></p>
<p>数学计算，注意运算符前后的空格不可缺少</p>
<p> <strong>文件系统</strong></p>
<p>$<strong>du -sh dir</strong></p>
<p>显示文件夹大小， -h 人类可读的单位， -s 摘要信息</p>
<p>$<strong>find pathname -option [-print]<br> [-exec -ok command] {}  \</strong></p>
<p>其中的option常用的有name,perm,mtime,size,depth,type等等，print就是打印找到的东西，exec和ok都是对找到的文件执行command的命令，区别在于ok会询问用户，{}指代了查找到的文件注意{}和\之间的空格。其实也可以用管道加xargs，效果同exec。</p>
<p>$<strong>cd ~</strong></p>
<p>回到主目录</p>
<p>$<strong>cd -</strong></p>
<p>回到上次操作的目录</p>
<p>$<strong>df</strong></p>
<p>检查文件系统磁盘空间占用情况</p>
<p>$<strong>fdisk</strong></p>
<p>对磁盘进行分区</p>
<p> <strong>进程</strong></p>
<p>$<strong>top</strong></p>
<p>显示进程信息，并实时更新。包含的内容很多，有负载情况，内存、CPU的使用情况，swap，进程状态等等</p>
<p>$<strong>ps</strong></p>
<p>显示当前shell下的进程</p>
<p>$<strong>kill PID</strong></p>
<p>杀死PID进程</p>
<p>$<strong>kill %job</strong></p>
<p>杀死job工作</p>
<p>$<strong>dmesg</strong></p>
<p>显示系统日志</p>
<p> <strong>网络</strong></p>
<p>$<strong>ifconfig</strong></p>
<p>显示网络接口以及ip地址</p>
<p>$<strong>route</strong></p>
<p>显示路由表，也可以用于修改路由表</p>
<p>$<strong>netstat</strong></p>
<p>显示当前网络连接状态</p>
<p>$<strong>ping IP</strong></p>
<p>发送ping包到地址ip</p>
<p>$<strong>traceroute ip</strong></p>
<p>探测到地址ip的路由路径</p>
<p>$<strong>wget url</strong></p>
<p>下载URL指向的资源</p>
<p>上面的命令都是一些最简单的介绍，参数什么的都没有具体讲，学习最主要的是方法，知道一些命令的大概功能后，不懂的man一下就行了。让我们在linux的世界里愉快的玩耍吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位运算]]></title>
    <link href="http://yoursite.com/2016/01/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/01/04/位运算/</id>
    <published>2016-01-04T13:28:29.000Z</published>
    <updated>2016-01-05T01:53:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>在计算机中数字是以二进制存储运算的，除了加减乘除等代数运算，与非等逻辑关系运算用二进制也十分方便。平时习惯了十进制的，思维难免有所局限，有些问题合理利用位运算性质常常能够简单快速的解决。下面我就介绍一下位运算的常用性质以及相关问题。</p>
<p><strong>1.判断奇偶性</strong></p>
<p>要想判断一个数的奇偶性，我们恐怕第一反应就是将其除以2然后看起余数。<br>这样肯定是可以的，但是这是不是最快的呢？既然问了这个问题，那答案显然就不是啦。计算机里的二进制数据做除法是很复杂的，所以我们得转换一下思路。奇数偶数在二进制里特点很明显，最后一位如果是1那显然就是奇数，如果是0那就是偶数。于是问题转化为判断最后一位是0是1，这用一个运算速度很快的&amp;（与）操作就能完成。示例代码如下</p>
<p>  int isOdd(int x)<br>{</p>
<pre><code>int <span class="literal">a</span>=<span class="number">0</span>x01<span class="comment">;</span>

<span class="keyword">return</span> (x&amp;<span class="literal">a</span>)<span class="comment">;</span>
</code></pre><p>}</p>
<p><strong>2.交换两个数</strong></p>
<p>在排序算法中经常涉及到交换两个数a,b，这个也不难，引入一个中间变量即可。但是如果加入一个限制条件，不允许有中间变量，那怎么办呢？思索一下，有的人可能会想到这样做</p>
<blockquote>
<p>a = a + b; b = a - b; a = a - b;</p>
</blockquote>
<p>很好，上面的方法没有用到中间变量实现了两个数的交换。还有没有其他方法呢？不了解同或异或及其性质的童鞋恐怕就很难想出来了。</p>
<p>同或，就是相同为1，不同为0，用符号表示就是</p>
<blockquote>
<p>1⊙1 = 1，0⊙0 = 1，0⊙1 = 0,1⊙0 = 0</p>
</blockquote>
<p>异或，就是不同为1，相同为0，用符号表示</p>
<blockquote>
<p>1⊕0 = 1，0⊕1 = 1, 0⊕0 = 0,1⊕1 = 0</p>
</blockquote>
<p>从上面的定义中我们可以推出一些基本性质，对于异或来说就是<strong>a⊕a=0, a⊕0=a</strong>,根据这两条性质我们就可以完成上面提出的问题。</p>
<blockquote>
<p>a = a⊕b; b = a⊕b; a = a⊕b;</p>
</blockquote>
<p>而且从形式上看，两种方法是极其相似的。</p>
<p><strong>3.寻找奇数出现</strong></p>
<p>标题说的不太清楚，这个问题是有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，找到这个数，要求时间复杂度为O(N)，额外空间复杂度为O(1)。</p>
<p>看到这个偶数次脑海里是不是马上想起了a⊕a=0，恭喜你，解决问题的关键就在这。因为数组里只有一个数出现了奇数次，我们把所有数迭代做异或，那么出现偶数次的数异或结果为0(有点像消消乐，把那些成对的消掉了)，最后的结果就是0异或那个出现奇数次的数，根据性质a⊕0=a,所以最终迭代结果就是那个数。示例代码如下</p>
<p>  int findOdd(vector<int> A, int n)</int></p>
<p>{</p>
<pre><code><span class="keyword">int</span> i;
<span class="keyword">int</span> odd=<span class="number">0</span>;
<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)
    odd ^= A[i];  <span class="comment">//a^a=0; a^0 = a</span>
<span class="keyword">return</span> odd;
</code></pre><p>}</p>
<p>位运算用途广泛，除了上面几个方面还常用于清零，提取某些位，移位等等，因为直接操作位，一般速度很快，所以搜索引擎里也能看到其身影。下次遇到问题不妨先想一下位运算能不能解决呢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="位运算 异或" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[short URL]]></title>
    <link href="http://yoursite.com/2015/12/12/short-URL/"/>
    <id>http://yoursite.com/2015/12/12/short-URL/</id>
    <published>2015-12-12T09:44:10.000Z</published>
    <updated>2015-12-13T01:50:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>之前在看&lt;&lt;文明之光&gt;&gt;的时候，作者吴军会在一些引用或者参考文献给出链接，好让读者进一步了解内容。但是我发现很多链接都是t.cn开头后面再跟上几个很随机的数字字母，当时有点纳闷，这个网站能包罗如此题材丰富的内容？顺便还鄙视了一下这域名太差了吧，一点含义都没,后面的随机字符又是什么鬼。后来偶然间好像是在豆瓣上又看到一个这样的链接，这次我的好奇心被彻底勾了起来，马上搜索了一下，这就是我们今天的主题<strong>短URL</strong>。</p>
<p>短URL，顾名思义就是把一个长的域名变为短的域名。那这有什么用呢？就比如我上面提到的吴军书中给的链接，你在浏览器中只要输入10个左右字符就可以代替原来可能十几甚至几十个的字符的链接，是不是感觉又可以愉快的玩耍了。吴军老师连这种细节都考虑到了，真是让人佩服啊。除此以外，一条微博规定不能超过140字符，如果你想带一个链接很可能话都说不了了，短信也差不多。这时候短URL简直就是神器有木有。</p>
<p>上面提到的t.cn是新浪提供的短网址服务，<a href="https://goo.gl/" target="_blank" rel="external">谷歌</a>，<a href="http://dwz.cn/" target="_blank" rel="external">百度</a>等也都有自己的服务。下图是我用谷歌把自己博客网址变短的效果图。<br><img src="http://7xp01p.com1.z0.glb.clouddn.com/short_urlshort_url.jpg" alt="short_url"></p>
<p>废话说了这么多，那短网址服务的原理是什么呢？我们不妨从实际生活中寻找一些灵感。众所周知，俄国人的名字是很长的，比如&lt;&lt;钢铁是怎样炼成的&gt;&gt;作者全名叫做尼古拉·阿耶克塞耶维奇·奥斯特洛夫斯基。想象一下我们的小尼古拉在上学的时候，老师要找他的考试成绩会按照名字来找么。显然不会，我们已经想到学生都会有一个学号，这个学号就代表了这个人名。对人名的操作会映射到学号上来，学号简单规范，方便不少。这样想来，短URL就相当于原来长URL的学号，我们要做的就是找一个两者之间的映射而已。</p>
<p>那这个映射有什么要求呢？显然不同网址映射后不能相同，再者对于一个映射后的短网址能够逆向解析出唯一一个原来的长网址。这些都是必须的要求，在这个基础上，映射后的短地址尽量要短。下面用数学语言来描述一下。</p>
<p>短址本质上是实现了一个映射函数 f: X -&gt; Y 。而这个映射函数必须同时具有两个特点：</p>
<ul>
<li>如果 x1 != x2, 则 f (x1) != f(x2);</li>
<li>对于每一个 y, 能够找到唯一的一个 x 使得 f(x) = y;</li>
</ul>
<p>假设我们现在有了短地址，浏览器是如何找到原来的长地址的呢？当我们在浏览器输入<a href="http://goo.gl/XdWWYX" target="_blank" rel="external">http://goo.gl/XdWWYX</a>时，DNS首先解析出goo.gl的IP地址，然后会向其发出HTTP GET请求查询XdWWYX。这个时候goo.gl服务器会逆向解析出长URL erping.github.io 再返回浏览器一个HTTP 301 重定向到长URL，后面就跟访问普通网站一样了。</p>
<p>至此，短网址基本讲清楚了。如果想要了解具体用什么映射实现的请往下看。</p>
<p>短URL长度一般6位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以6位的话，总共会有 62^6 ~= 568亿种组合，基本上够用了。</p>
<p>假设我们用数据库来保存长地址和短地址的映射，那么，在表 LongtoShortURL 中，我们会有三列：</p>
<ol>
<li>ID，int,  自动增长；</li>
<li>LURL，varchar;  // 长URL；</li>
<li>SURL, varchar; // 短URL。</li>
</ol>
<p>现在我们考虑通过如何长URL得到唯一的短URL。</p>
<p>在讲具体算法以前，先提一个问题：10进制数和16进制数之间的转换是否满足刚刚提到的映射函数 f: X -&gt; Y中的两个条件？答案： 是。</p>
<p>本文的思路也是利用进制之间的转换。因为我们总共有 62 个字母([a-z],[A-Z],[0-9])，我们可以自创一种进制，叫做 62 进制。其规则如下：</p>
<blockquote>
<p>0  -&gt;  a<br>1  -&gt;  b<br>2  -&gt;  c<br>…..<br>61 -&gt;  9</p>
</blockquote>
<p>所以，对于每一个长地址，我们可以根据它的ID，将其用62进制表示得到一个6位的 62 进制数，这个6位的 62 进制数就是我们的短址。比如，对于 ID = 138，62进制表示为2余14，转化为6位表示为[0,0,0,0,2,14]，根据上面的对应规则表，我们可以得到其对应的短址为：aaaabn 。</p>
<p>当我们想通过短址找到所对应的长地址，方法也很简单，就是把62进制数转成10进制数即可，这样我们就可以得到长地址的ID了。比如，对于短址aaae9a，其62进制为[0, 0, 0, 4,61,0] ，则其长地址的ID 为[0, 0, 0, 4,61,0] = 0×62^5+ 0×62^4 + 0×62^3 + 4×62^2 + 61×62^1 + 0×62^0 = 1915810。有了ID，我们自然就可以得到长地址了。</p>
<p>参考：<br><a href="http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener" target="_blank" rel="external">http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener</a><br><a href="http://blog.csdn.net/beiyeqingteng/article/details/7706010" target="_blank" rel="external">http://blog.csdn.net/beiyeqingteng/article/details/7706010</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="short_url" scheme="http://yoursite.com/tags/short-url/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[about]]></title>
    <link href="http://yoursite.com/2015/12/08/about/"/>
    <id>http://yoursite.com/2015/12/08/about/</id>
    <published>2015-12-08T06:54:57.000Z</published>
    <updated>2015-12-08T06:54:57.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo你的博客]]></title>
    <link href="http://yoursite.com/2015/12/08/hexo-your-blog/"/>
    <id>http://yoursite.com/2015/12/08/hexo-your-blog/</id>
    <published>2015-12-08T03:46:12.000Z</published>
    <updated>2015-12-08T07:43:58.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>很早以前就在自己的Todo List里加入了写博客一项，只是懒癌发作迟迟没有动手。最近闲来无事，便花了点时间折腾了一番。其实之前在vps上搭建了WordPress,但是感觉主题太丑，加功能什么的操作复杂，自己都不愿意访问，后来就搁浅了。这次决定在GitHub写了，然后看了看推荐比较多的hexo，逼格满满啊，马上就开始动手了。于是就有了这篇处女博，大概记录一下过程，供人参考。</p>
<p>为了贯彻落实不重复造轮子的理念（一个字，懒），我还是给一个链接吧，<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a>,这篇博客详细的写了整个搭建过程，写的很好。我基本就是按照这个来的，大问题没有，中间出了点小问题就是本地搭建完成访问没问题，但是部署到GitHub上后没效果，纠结了一会上网查了以后发现是在配置文件里每个配置项的冒号：后要加一个空格才能写内容。我就是少了一个空格，所以一直没有把代码提交上去。关键是他还不报错，就算报错也不能精确定位，这也算是hexo的一个不足之处。不过瑕不掩瑜，hexo简约，大方，还是很方便滴。</p>
<p>博客建完以后，爱折腾的人估计会对主题不太满意，没关系，开源社区里早就有人开发了多种主题供您挑选，满足个性化需求。<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="external">好看的hexo主题</a>里面家顺张的回答里根据star数做了一个排名，多试一试总会找到符合心意的，顺便说一下从网站下面可以看到我的主题是Next。Next主题的安装配置<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">在这里</a>。</p>
<p>本来想写成一个一步步搭建hexo的博客，结果成了一个介绍别人搭建hexo博客的博客，/(ㄒoㄒ)/~~。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="NexT" scheme="http://yoursite.com/tags/NexT/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="Essay" scheme="http://yoursite.com/categories/Essay/"/>
    
  </entry>
  
</feed>
