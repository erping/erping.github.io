<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[薛定谔的喵]]></title>
  <subtitle><![CDATA[成长之路]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-04-13T08:51:48.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[erping]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Bash快捷键]]></title>
    <link href="http://yoursite.com/2016/04/13/Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2016/04/13/Bash快捷键/</id>
    <published>2016-04-13T08:50:07.000Z</published>
    <updated>2016-04-13T08:51:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>当你输入了一长串的命令却发现开头有错误的时候，你会一直按&lt;-使光标移动过去么？当你忘记之前输入的命令的全称的时候你会先history然后执行么？少年，工欲善其事必先利其器，学习一些bash快捷键让你又cool又快。</p>
<p>Ctrl-A 相当于HOME键，用于将光标定位到本行最前面</p>
<p><strong>Ctrl-E 相当于End键，即将光标移动到本行末尾</strong></p>
<p>Ctrl-B 相当于左箭头键，用于将光标向左移动一格</p>
<p>Ctrl-F 相当于右箭头键，用于将光标向右移动一格</p>
<p>Ctrl-D 相当于Del键，即删除光标所在处的字符</p>
<p>Ctrl-K 用于删除从光标处开始到结尾处的所有字符</p>
<p><strong>Ctrl-L 清屏，相当于clear命令</strong></p>
<p><strong>Ctrl-R 进入历史命令查找状态，然后你输入几个关键字符，就可以找到你使用过的命令</strong></p>
<p><strong>Ctrl-U 用于删除从光标开始到行首的所有字符。一般在密码或命令输入错误时常用</strong></p>
<p>Ctrl-H 删除光标左侧的一个字符</p>
<p>Ctrl-W 用于删除当前光标左侧的一个单词</p>
<p><strong>Ctrl-P 相当于上箭头键，即显示上一个命令</strong></p>
<p>Ctrl-N 相当于下箭头键，即显示下一个命令</p>
<p>Ctrl-J 相当于回车键</p>
<p>Alt-. 用于提取历史命令中的最后一个单词。你先执行history命令，然后再敲击此快捷键若干下，你就懂了！</p>
<p>Alt-BackSpace 用于删除本行所有的内容，基本上和Ctrl-U类似。</p>
<p>Alt-C 用于将当前光标处的字符变成大写，同时本光标所在单词的后续字符都变成小写。</p>
<p>Alt-L 用于将光标所在单词及所在单词的后续字符都变成小写。</p>
<p>Alt-U 用于将光标所在单词的光标所在处及之后的所有字符变成大写。</p>
<p>黑体的是推荐的常用快捷键，多用几次很快就熟悉啦。人生又省出很多时间，可以进行思考了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux创建进程的方法]]></title>
    <link href="http://yoursite.com/2016/03/02/Linux%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/03/02/Linux创建进程的方法/</id>
    <published>2016-03-02T14:51:00.000Z</published>
    <updated>2016-04-02T14:58:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>在Linux中主要提供了fork、vfork、clone三种创建进程的方法。下面我们分别介绍他们的特点以及不同之处。</p>
<p><strong>fork</strong></p>
<p>创建进程最常用的就是fork，这样得到的子进程完全复制父进程的资源，仅有少量信息如task_struct结构和pid父子进程是不同的。但是比如文件描述符，打开的文件的读写位置指针等都是相同的。这样得到的子进程独立于父进程，具有良好的并发性，但是两者之间的通信需要专门的通信机制比如管道，共享内存。因为子进程存有父进程的资源副本，所以fork是一个开销很大的系统调用。有时候这样是很不必要的，比如fork出来的子进程仅仅是为了调用exec执行另外的程序，那么fork过程的复制将是一个多余的过程。现在的Linux采用了写时复制的技术，为了降低开销，fork最初并不会真正产生两个不同的拷贝，因为那个时候，大量的数据其实是一样的。写时复制推迟了真正的数据拷贝。若后来确实发生了写入，那那意味着parent和child的数据不一致了，于是产生复制动作，每个进程拿到属于自己的那一份，这样就可以降低系统调用的开销。所以有了写时复制后呢，vfork其实现意义就不大了(后面会讲到)。</p>
<p>fork调用执行一次返回两个值，对于父进程，fork函数返回子程序的进程号，而对于子程序，fork函数则返回零，这就是一个函数返回两次的本质。 </p>
<p>在fork之后，子进程和父进程都会继续执行fork调用之后的指令。子进程是父进程的副本。它将获得父进程的数据空间，堆和栈的副本，这些都是副本，父子进程并不共享这部分的内存。也就是说，子进程对父进程中的同名变量进行修改并不会影响其在父进程中的值。但是父子进程又共享一些东西，简单说来就是程序的正文段。正文段存放着由cpu执行的机器指令，通常是read-only的。</p>
<p><strong>vfork</strong></p>
<p>既然有了fork，为什么还会有vfork呢？看fork的man page我们就可以知道啦。</p>
<p><em>In the bad old days a fork would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterwards an exec is done. Thus, for greater efficiency, BSD introduced the vfork system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of control until a call to execve or an exit occurred. The parent process was suspended while the child was using its resources. The use of vfork was tricky: for example, not modifying data in the parent process depended on knowing which variables are held in a register</em></p>
<p>就是为了处理上文分析的fork后子进程马上exec一个外部程序使得复制没意义这样的问题，BSD提出了vfork，这样会使父子进程共享地址空间。这个时候如果子进程修改了某个变量，父进程也会做同样的修改。</p>
<p>但此处有一点要注意的是用vfork创建的子进程必须显示调用exit()来结束，用return会挂掉，详细情况有兴趣的可以参考<a href="http://coolshell.cn/articles/12103.html" target="_blank" rel="external">这篇文章</a>。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec或exit，这也就是说vfork会保证子进程先运行，而fork的情况下两者是竞争关系，运行顺序无法得到保证。</p>
<p><strong>clone</strong></p>
<p>clone的函数原型<br>int clone(int (<em>fn)(void </em>), void <em>child_stack, int flags, void </em>arg);</p>
<p>系统调用fork和vfork是无参数的，而clone则带有参数。fork是全部复制，vfork是共享内存，而clone是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 flags来决定。另外，clone返回的是子进程的pid。</p>
<p>以上就是Linux下的几种创建进程的方式，vfork比较危险，如果不是特别关注性能不建议使用，clone提供了复杂的参数，可以实现对子进程较为精细的控制，在实践中应该根据自己需求选择合适的调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="clone" scheme="http://yoursite.com/tags/clone/"/>
    
      <category term="fork" scheme="http://yoursite.com/tags/fork/"/>
    
      <category term="vfork" scheme="http://yoursite.com/tags/vfork/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <link href="http://yoursite.com/2016/01/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/01/30/linux常用命令/</id>
    <published>2016-01-30T03:06:24.000Z</published>
    <updated>2016-03-30T03:20:42.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>自己电脑以前用的就是Ubuntu的，虽然不怎么方便，但是命令用的熟啊。后来重装了Windows，命令逐渐生疏，今天就总结一下，算是温故知新。</p>
<p> <strong>帮助命令</strong></p>
<p>$<strong>man</strong> <em>command</em></p>
<p>查询命令<em>command</em>的说明文档</p>
<p>$<strong>info</strong> <em>command</em></p>
<p>更加详细的说明文档</p>
<p>$<strong>whatis</strong> <em>command</em></p>
<p>简要说明</p>
<p>$<strong>which</strong> <em>command</em></p>
<p><em>command</em>的binary文件所在路径</p>
<p>$<strong>whereis</strong> <em>command</em></p>
<p>在搜索路径中的所有<em>command</em></p>
<p> <strong>用户</strong></p>
<p>$<strong>finger</strong> <em>username</em></p>
<p>显示用户<em>username</em>的信息</p>
<p>$<strong>who</strong></p>
<p>显示当前登录的用户</p>
<p>$<strong>passwd</strong></p>
<p>更改密码</p>
<p> <strong>SHELL（BASH）</strong></p>
<p>$<strong>history</strong></p>
<p>显示当前shell下的命令历史</p>
<p>$<strong>!num</strong></p>
<p>!加在<em>history</em>后的数字即为执行那条命令</p>
<p>$<strong>alias</strong></p>
<p>显示所有的命令别名</p>
<p>$<strong>alias new_command=’command’</strong></p>
<p>将command用newcommand代替</p>
<p>$<strong>expr 1 + 1</strong></p>
<p>数学计算，注意运算符前后的空格不可缺少</p>
<p> <strong>文件系统</strong></p>
<p>$<strong>du -sh dir</strong></p>
<p>显示文件夹大小， -h 人类可读的单位， -s 摘要信息</p>
<p>$<strong>find pathname -option [-print]<br> [-exec -ok command] {}  \</strong></p>
<p>其中的option常用的有name,perm,mtime,size,depth,type等等，print就是打印找到的东西，exec和ok都是对找到的文件执行command的命令，区别在于ok会询问用户，{}指代了查找到的文件注意{}和\之间的空格。其实也可以用管道加xargs，效果同exec。</p>
<p>$<strong>cd ~</strong></p>
<p>回到主目录</p>
<p>$<strong>cd -</strong></p>
<p>回到上次操作的目录</p>
<p>$<strong>df</strong></p>
<p>检查文件系统磁盘空间占用情况</p>
<p>$<strong>fdisk</strong></p>
<p>对磁盘进行分区</p>
<p> <strong>进程</strong></p>
<p>$<strong>top</strong></p>
<p>显示进程信息，并实时更新。包含的内容很多，有负载情况，内存、CPU的使用情况，swap，进程状态等等</p>
<p>$<strong>ps</strong></p>
<p>显示当前shell下的进程</p>
<p>$<strong>kill PID</strong></p>
<p>杀死PID进程</p>
<p>$<strong>kill %job</strong></p>
<p>杀死job工作</p>
<p>$<strong>dmesg</strong></p>
<p>显示系统日志</p>
<p> <strong>网络</strong></p>
<p>$<strong>ifconfig</strong></p>
<p>显示网络接口以及ip地址</p>
<p>$<strong>route</strong></p>
<p>显示路由表，也可以用于修改路由表</p>
<p>$<strong>netstat</strong></p>
<p>显示当前网络连接状态</p>
<p>$<strong>ping IP</strong></p>
<p>发送ping包到地址ip</p>
<p>$<strong>traceroute ip</strong></p>
<p>探测到地址ip的路由路径</p>
<p>$<strong>wget url</strong></p>
<p>下载URL指向的资源</p>
<p>上面的命令都是一些最简单的介绍，参数什么的都没有具体讲，学习最主要的是方法，知道一些命令的大概功能后，不懂的man一下就行了。让我们在linux的世界里愉快的玩耍吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位运算]]></title>
    <link href="http://yoursite.com/2016/01/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/01/04/位运算/</id>
    <published>2016-01-04T13:28:29.000Z</published>
    <updated>2016-01-05T01:53:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>在计算机中数字是以二进制存储运算的，除了加减乘除等代数运算，与非等逻辑关系运算用二进制也十分方便。平时习惯了十进制的，思维难免有所局限，有些问题合理利用位运算性质常常能够简单快速的解决。下面我就介绍一下位运算的常用性质以及相关问题。</p>
<p><strong>1.判断奇偶性</strong></p>
<p>要想判断一个数的奇偶性，我们恐怕第一反应就是将其除以2然后看起余数。<br>这样肯定是可以的，但是这是不是最快的呢？既然问了这个问题，那答案显然就不是啦。计算机里的二进制数据做除法是很复杂的，所以我们得转换一下思路。奇数偶数在二进制里特点很明显，最后一位如果是1那显然就是奇数，如果是0那就是偶数。于是问题转化为判断最后一位是0是1，这用一个运算速度很快的&amp;（与）操作就能完成。示例代码如下</p>
<p>  int isOdd(int x)<br>{</p>
<pre><code>int <span class="literal">a</span>=<span class="number">0</span>x01<span class="comment">;</span>

<span class="keyword">return</span> (x&amp;<span class="literal">a</span>)<span class="comment">;</span>
</code></pre><p>}</p>
<p><strong>2.交换两个数</strong></p>
<p>在排序算法中经常涉及到交换两个数a,b，这个也不难，引入一个中间变量即可。但是如果加入一个限制条件，不允许有中间变量，那怎么办呢？思索一下，有的人可能会想到这样做</p>
<blockquote>
<p>a = a + b; b = a - b; a = a - b;</p>
</blockquote>
<p>很好，上面的方法没有用到中间变量实现了两个数的交换。还有没有其他方法呢？不了解同或异或及其性质的童鞋恐怕就很难想出来了。</p>
<p>同或，就是相同为1，不同为0，用符号表示就是</p>
<blockquote>
<p>1⊙1 = 1，0⊙0 = 1，0⊙1 = 0,1⊙0 = 0</p>
</blockquote>
<p>异或，就是不同为1，相同为0，用符号表示</p>
<blockquote>
<p>1⊕0 = 1，0⊕1 = 1, 0⊕0 = 0,1⊕1 = 0</p>
</blockquote>
<p>从上面的定义中我们可以推出一些基本性质，对于异或来说就是<strong>a⊕a=0, a⊕0=a</strong>,根据这两条性质我们就可以完成上面提出的问题。</p>
<blockquote>
<p>a = a⊕b; b = a⊕b; a = a⊕b;</p>
</blockquote>
<p>而且从形式上看，两种方法是极其相似的。</p>
<p><strong>3.寻找奇数出现</strong></p>
<p>标题说的不太清楚，这个问题是有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，找到这个数，要求时间复杂度为O(N)，额外空间复杂度为O(1)。</p>
<p>看到这个偶数次脑海里是不是马上想起了a⊕a=0，恭喜你，解决问题的关键就在这。因为数组里只有一个数出现了奇数次，我们把所有数迭代做异或，那么出现偶数次的数异或结果为0(有点像消消乐，把那些成对的消掉了)，最后的结果就是0异或那个出现奇数次的数，根据性质a⊕0=a,所以最终迭代结果就是那个数。示例代码如下</p>
<p>  int findOdd(vector<int> A, int n)</int></p>
<p>{</p>
<pre><code><span class="keyword">int</span> i;
<span class="keyword">int</span> odd=<span class="number">0</span>;
<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)
    odd ^= A[i];  <span class="comment">//a^a=0; a^0 = a</span>
<span class="keyword">return</span> odd;
</code></pre><p>}</p>
<p>位运算用途广泛，除了上面几个方面还常用于清零，提取某些位，移位等等，因为直接操作位，一般速度很快，所以搜索引擎里也能看到其身影。下次遇到问题不妨先想一下位运算能不能解决呢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="位运算 异或" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BC%82%E6%88%96/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[short URL]]></title>
    <link href="http://yoursite.com/2015/12/12/short-URL/"/>
    <id>http://yoursite.com/2015/12/12/short-URL/</id>
    <published>2015-12-12T09:44:10.000Z</published>
    <updated>2015-12-13T01:50:05.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>之前在看&lt;&lt;文明之光&gt;&gt;的时候，作者吴军会在一些引用或者参考文献给出链接，好让读者进一步了解内容。但是我发现很多链接都是t.cn开头后面再跟上几个很随机的数字字母，当时有点纳闷，这个网站能包罗如此题材丰富的内容？顺便还鄙视了一下这域名太差了吧，一点含义都没,后面的随机字符又是什么鬼。后来偶然间好像是在豆瓣上又看到一个这样的链接，这次我的好奇心被彻底勾了起来，马上搜索了一下，这就是我们今天的主题<strong>短URL</strong>。</p>
<p>短URL，顾名思义就是把一个长的域名变为短的域名。那这有什么用呢？就比如我上面提到的吴军书中给的链接，你在浏览器中只要输入10个左右字符就可以代替原来可能十几甚至几十个的字符的链接，是不是感觉又可以愉快的玩耍了。吴军老师连这种细节都考虑到了，真是让人佩服啊。除此以外，一条微博规定不能超过140字符，如果你想带一个链接很可能话都说不了了，短信也差不多。这时候短URL简直就是神器有木有。</p>
<p>上面提到的t.cn是新浪提供的短网址服务，<a href="https://goo.gl/" target="_blank" rel="external">谷歌</a>，<a href="http://dwz.cn/" target="_blank" rel="external">百度</a>等也都有自己的服务。下图是我用谷歌把自己博客网址变短的效果图。<br><img src="http://7xp01p.com1.z0.glb.clouddn.com/short_urlshort_url.jpg" alt="short_url"></p>
<p>废话说了这么多，那短网址服务的原理是什么呢？我们不妨从实际生活中寻找一些灵感。众所周知，俄国人的名字是很长的，比如&lt;&lt;钢铁是怎样炼成的&gt;&gt;作者全名叫做尼古拉·阿耶克塞耶维奇·奥斯特洛夫斯基。想象一下我们的小尼古拉在上学的时候，老师要找他的考试成绩会按照名字来找么。显然不会，我们已经想到学生都会有一个学号，这个学号就代表了这个人名。对人名的操作会映射到学号上来，学号简单规范，方便不少。这样想来，短URL就相当于原来长URL的学号，我们要做的就是找一个两者之间的映射而已。</p>
<p>那这个映射有什么要求呢？显然不同网址映射后不能相同，再者对于一个映射后的短网址能够逆向解析出唯一一个原来的长网址。这些都是必须的要求，在这个基础上，映射后的短地址尽量要短。下面用数学语言来描述一下。</p>
<p>短址本质上是实现了一个映射函数 f: X -&gt; Y 。而这个映射函数必须同时具有两个特点：</p>
<ul>
<li>如果 x1 != x2, 则 f (x1) != f(x2);</li>
<li>对于每一个 y, 能够找到唯一的一个 x 使得 f(x) = y;</li>
</ul>
<p>假设我们现在有了短地址，浏览器是如何找到原来的长地址的呢？当我们在浏览器输入<a href="http://goo.gl/XdWWYX" target="_blank" rel="external">http://goo.gl/XdWWYX</a>时，DNS首先解析出goo.gl的IP地址，然后会向其发出HTTP GET请求查询XdWWYX。这个时候goo.gl服务器会逆向解析出长URL erping.github.io 再返回浏览器一个HTTP 301 重定向到长URL，后面就跟访问普通网站一样了。</p>
<p>至此，短网址基本讲清楚了。如果想要了解具体用什么映射实现的请往下看。</p>
<p>短URL长度一般6位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以6位的话，总共会有 62^6 ~= 568亿种组合，基本上够用了。</p>
<p>假设我们用数据库来保存长地址和短地址的映射，那么，在表 LongtoShortURL 中，我们会有三列：</p>
<ol>
<li>ID，int,  自动增长；</li>
<li>LURL，varchar;  // 长URL；</li>
<li>SURL, varchar; // 短URL。</li>
</ol>
<p>现在我们考虑通过如何长URL得到唯一的短URL。</p>
<p>在讲具体算法以前，先提一个问题：10进制数和16进制数之间的转换是否满足刚刚提到的映射函数 f: X -&gt; Y中的两个条件？答案： 是。</p>
<p>本文的思路也是利用进制之间的转换。因为我们总共有 62 个字母([a-z],[A-Z],[0-9])，我们可以自创一种进制，叫做 62 进制。其规则如下：</p>
<blockquote>
<p>0  -&gt;  a<br>1  -&gt;  b<br>2  -&gt;  c<br>…..<br>61 -&gt;  9</p>
</blockquote>
<p>所以，对于每一个长地址，我们可以根据它的ID，将其用62进制表示得到一个6位的 62 进制数，这个6位的 62 进制数就是我们的短址。比如，对于 ID = 138，62进制表示为2余14，转化为6位表示为[0,0,0,0,2,14]，根据上面的对应规则表，我们可以得到其对应的短址为：aaaabn 。</p>
<p>当我们想通过短址找到所对应的长地址，方法也很简单，就是把62进制数转成10进制数即可，这样我们就可以得到长地址的ID了。比如，对于短址aaae9a，其62进制为[0, 0, 0, 4,61,0] ，则其长地址的ID 为[0, 0, 0, 4,61,0] = 0×62^5+ 0×62^4 + 0×62^3 + 4×62^2 + 61×62^1 + 0×62^0 = 1915810。有了ID，我们自然就可以得到长地址了。</p>
<p>参考：<br><a href="http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener" target="_blank" rel="external">http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener</a><br><a href="http://blog.csdn.net/beiyeqingteng/article/details/7706010" target="_blank" rel="external">http://blog.csdn.net/beiyeqingteng/article/details/7706010</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="short_url" scheme="http://yoursite.com/tags/short-url/"/>
    
      <category term="tech" scheme="http://yoursite.com/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[about]]></title>
    <link href="http://yoursite.com/2015/12/08/about/"/>
    <id>http://yoursite.com/2015/12/08/about/</id>
    <published>2015-12-08T06:54:57.000Z</published>
    <updated>2015-12-08T06:54:57.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo你的博客]]></title>
    <link href="http://yoursite.com/2015/12/08/hexo-your-blog/"/>
    <id>http://yoursite.com/2015/12/08/hexo-your-blog/</id>
    <published>2015-12-08T03:46:12.000Z</published>
    <updated>2015-12-08T07:43:58.000Z</updated>
    <content type="html"><![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="external">喝咖啡</a></strong></p>
<p>很早以前就在自己的Todo List里加入了写博客一项，只是懒癌发作迟迟没有动手。最近闲来无事，便花了点时间折腾了一番。其实之前在vps上搭建了WordPress,但是感觉主题太丑，加功能什么的操作复杂，自己都不愿意访问，后来就搁浅了。这次决定在GitHub写了，然后看了看推荐比较多的hexo，逼格满满啊，马上就开始动手了。于是就有了这篇处女博，大概记录一下过程，供人参考。</p>
<p>为了贯彻落实不重复造轮子的理念（一个字，懒），我还是给一个链接吧，<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a>,这篇博客详细的写了整个搭建过程，写的很好。我基本就是按照这个来的，大问题没有，中间出了点小问题就是本地搭建完成访问没问题，但是部署到GitHub上后没效果，纠结了一会上网查了以后发现是在配置文件里每个配置项的冒号：后要加一个空格才能写内容。我就是少了一个空格，所以一直没有把代码提交上去。关键是他还不报错，就算报错也不能精确定位，这也算是hexo的一个不足之处。不过瑕不掩瑜，hexo简约，大方，还是很方便滴。</p>
<p>博客建完以后，爱折腾的人估计会对主题不太满意，没关系，开源社区里早就有人开发了多种主题供您挑选，满足个性化需求。<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="external">好看的hexo主题</a>里面家顺张的回答里根据star数做了一个排名，多试一试总会找到符合心意的，顺便说一下从网站下面可以看到我的主题是Next。Next主题的安装配置<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">在这里</a>。</p>
<p>本来想写成一个一步步搭建hexo的博客，结果成了一个介绍别人搭建hexo博客的博客，/(ㄒoㄒ)/~~。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>转载请注明作者及出处，如果你觉得这篇文章对你有帮助或启发，也可以来请我<a href="http://7xp01p.com1.z0.glb.clouddn.com/1449296258436.jpg" target="_blank" rel="externa]]>
    </summary>
    
      <category term="NexT" scheme="http://yoursite.com/tags/NexT/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="Essay" scheme="http://yoursite.com/categories/Essay/"/>
    
  </entry>
  
</feed>
